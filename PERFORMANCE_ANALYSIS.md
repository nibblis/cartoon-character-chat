### Анализ производительности: Оптимизация UI в AuthScreen

Это руководство демонстрирует процесс профилирования CPU для обнаружения и устранения "горячих точек" (hot spots) в коде, которые вызывают проблемы с производительностью UI (jank).

**Сценарий:** Пользователи жалуются на "тормоза" при вводе номера телефона на экране `AuthScreen`. Наша задача — найти причину и оптимизировать код.

--- 

### Часть 1: Анализ (До исправлений)

#### Шаг 1: Запуск CPU Profiler

1.  Запустите приложение на устройстве или эмуляторе.
2.  Откройте **Profiler** в Android Studio (View -> Tool Windows -> Profiler).
3.  Выберите ваше устройство и процесс приложения.
4.  Нажмите на таймлайн **CPU**, чтобы открыть CPU Profiler.
5.  Выберите конфигурацию **"Sample C/C++ Functions"** (или **"Trace System Calls"** для более детального трейса, включая рекомпозиции Compose).
6.  Нажмите **Record**. Начните взаимодействовать с экраном `AuthScreen` (например, вводить номер телефона).
7.  Через несколько секунд нажмите **Stop**.

#### Шаг 2: Интерпретация трейсов (Flame Chart)

После остановки записи вы увидите **Flame Chart** (пламенную диаграмму). Она визуализирует стек вызовов, где ширина каждого блока соответствует времени, затраченному на выполнение функции.

-   **Ищите широкие блоки:** Нас интересуют функции, которые занимают много времени CPU. Они являются "горячими точками".
-   **Анализ сверху вниз:** Верхние блоки — это функции, которые непосредственно потребляют CPU. Двигаясь вниз по диаграмме, вы видите, какие функции их вызвали.

**Что мы видим в нашем случае:**

При анализе трейса мы быстро обнаружим очень широкий блок, соответствующий функции `AuthScreenKt.fib`. Этот блок будет повторяться много раз, что указывает на его частое выполнение.

```
// Примерный вид Flame Chart

... [Compose-методы] ...
  AuthScreenKt.AuthScreen(...)
    AuthScreenKt.FibonacciText(...)
      AuthScreenKt.fib(n=35)  <-- ЭТОТ БЛОК ОЧЕНЬ ШИРОКИЙ
```

**Вывод:** Функция `fib` внутри `FibonacciText` является нашей "горячей точкой". Она выполняется в основном потоке (UI thread) при каждой рекомпозиции `AuthScreen`, блокируя его и вызывая "тормоза".

#### Шаг 3: План улучшений

1.  **Проблема:** Ресурсоемкая операция (`fib`) выполняется внутри Composable-функции.
2.  **Решение:** Вычисления, которые не нужно повторять при каждой рекомпозиции, должны быть вынесены и мемоизированы. В Jetpack Compose для этого используется `remember`.
3.  **План:** Обернуть вычисление `fib(number)` в `remember(number) { ... }`, чтобы результат вычислялся только один раз для заданного `number`, а затем переиспользовался при последующих рекомпозициях.

--- 

### Часть 2: Оптимизация и проверка (После исправлений)

#### Шаг 4: Применение оптимизации

Мы изменяем `FibonacciText` следующим образом:

```kotlin
@Composable
fun FibonacciText(number: Int) {
    fun fib(n: Int): Long {
        return if (n <= 1) n.toLong() else fib(n - 1) + fib(n - 2)
    }
    // Используем remember для кэширования результата
    val fibResult = remember(number) { fib(number) }
    Text(text = "Fibonacci: $fibResult", style = MaterialTheme.typography.bodySmall)
}
```

#### Шаг 5: Повторное профилирование и сравнение метрик

1.  Запускаем CPU Profiler еще раз с теми же шагами, что и в Части 1.
2.  Снова взаимодействуем с экраном.

**Результаты (До vs. После):**

| Метрика                  | До исправления (примерно) | После исправления (примерно) | Результат     |
| ------------------------ | ------------------------- | ---------------------------- | ------------- |
| **Время выполнения `fib`**   | ~200-300 мс на вызов      | ~0 мс (после первого вызова) | Значительное улучшение |
| **Ширина блока `fib`**     | Очень широкая             | Практически отсутствует        | Успех         |
| **Плавность UI**           | Заметные "тормоза" (jank)   | Плавно                       | Проблема решена |

**Вывод:**
После оптимизации с помощью `remember` "горячая точка" `fib` исчезла из трейсов. Ресурсоемкая операция больше не блокирует UI-поток при каждой рекомпозиции, и производительность экрана восстановлена.

Этот процесс демонстрирует полный цикл работы с производительностью: **обнаружение проблемы с помощью профилировщика, анализ трейсов для поиска корневой причины, разработка плана улучшений и проверка результатов для подтверждения эффективности исправлений.**
