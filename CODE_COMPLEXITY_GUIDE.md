### Руководство по управлению сложностью кода

Этот документ объясняет, как мы измеряем, контролируем и снижаем сложность кода, чтобы делать его более читаемым и поддерживаемым.

---

### 1. Что такое сложность и зачем ее контролировать?

**Цикломатическая сложность** — это метрика, которая измеряет количество "путей выполнения" в функции. Проще говоря, чем больше в функции `if`, `else`, `when`, `for`, `while`, тем выше ее сложность.

-   **Проблема:** Функции с высокой сложностью трудно читать, понимать, тестировать и изменять. Вероятность допустить в них ошибку гораздо выше.
-   **Решение:** Контролировать и снижать сложность.

### 2. Контроль статанализом и целевые пороги

Мы можем автоматически отслеживать сложность с помощью статического анализатора **Detekt**.

-   **Инструмент:** Detekt — самый популярный статический анализатор для Kotlin. Он интегрируется в Gradle и может "провалить" сборку, если сложность кода превышает заданный порог.
-   **Целевые пороги:** Для нашего проекта мы устанавливаем следующие пороги:
    -   **Сложность функции (CyclomaticComplexity):** не более **10**. Функции сложнее этого должны быть разделены на более мелкие.
    -   **Длина функции (FunctionLength):** не более **30 строк**. Длинные функции почти всегда делают слишком много.
-   **Почему такие пороги?** Это общепринятые в индустрии значения, которые обеспечивают хороший баланс между гибкостью и необходимостью поддерживать код в чистоте.

### 3. Техники снижения сложности: Early Return (Guard Clause)

Один из лучших способов снизить вложенность и сложность — использовать паттерн **Early Return**.

-   **Идея:** Вместо вложенных `if/else` мы делаем проверки на невалидные условия в самом начале функции и сразу же выходим из нее.

--- 

### 4. Пример рефакторинга: `AuthScreen.kt`

В `AuthScreen` блок `LaunchedEffect` имел лишнюю вложенность. Мы применили Early Return для его упрощения.

#### Diff (До -> После)

**Код ДО рефакторинга:**
```kotlin
LaunchedEffect(state.selectedCountry) {
    if (state.selectedCountry != null) {
        dialCodeValue = TextFieldValue(
            text = state.selectedCountry!!.code,
            selection = TextRange(state.selectedCountry!!.code.length)
        )
    }
}
```

**Код ПОСЛЕ рефакторинга (с Early Return):**
```kotlin
LaunchedEffect(state.selectedCountry) {
    val country = state.selectedCountry ?: return@LaunchedEffect

    dialCodeValue = TextFieldValue(
        text = country.code,
        selection = TextRange(country.code.length)
    )
}
```

**Результат:** Мы убрали один уровень вложенности и избавились от небезопасного оператора `!!`. Код стал более плоским, безопасным и идиоматичным для Kotlin.
