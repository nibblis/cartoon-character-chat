### Руководство по отладке: Поиск сбоя в AutoReplyViewModel

Это руководство демонстрирует, как использовать отладчик Android Studio для быстрой локализации и анализа бага на примере сбоя в `AutoReplyViewModel`.

**Сценарий:** У нас есть юнит-тест (`test timer ticks down correctly`), который падает. Мы подозреваем, что проблема в цикле таймера, но не знаем, где именно.

#### Шаг 1: Запуск теста в режиме отладки

1.  Откройте файл `AutoReplyViewModelTest.kt`.
2.  Нажмите на иконку "play" рядом с именем теста `test timer ticks down correctly` и выберите **Debug 'test timer ticks down correctly'**.

    Тест запустится и остановится на строке, где произошло исключение (`throw IllegalStateException(...)`).

#### Шаг 2: Чтение стека вызовов (Call Stack)

Когда выполнение остановится, посмотрите на панель **Debug** (внизу). Вкладка **Frames** показывает стек вызовов — это последовательность вызовов методов, которая привела к ошибке.

```
... (внешние вызовы из тестового фреймворка)
AutoReplyViewModel$startTimer$1.invokeSuspend(AutoReplyViewModel.kt:31)  <-- Наша проблема здесь
AutoReplyViewModelTest$test timer ticks down correctly$1.invokeSuspend(AutoReplyViewModelTest.kt:42)
... (корутины и тестовый код)
```

-   **Верхняя строка стека** — это место, где произошла ошибка.
-   **Строки ниже** — это "путь", который привел к этой точке.

Чтение стека снизу вверх помогает понять контекст: тест вызвал `startTimer`, который запустил корутину, и уже внутри нее произошел сбой. Это сразу сужает область поиска до `startTimer$1.invokeSuspend` (тело корутины).

#### Шаг 3: Локализация дефекта с условным брейкпоинтом

Представим, что мы не знаем точную причину, но подозреваем, что проблема возникает при определенном значении счетчика `i`. Вместо того чтобы останавливаться на каждой итерации цикла, мы используем **условный брейкпоинт**.

1.  **Установите брейкпоинт:** Нажмите на левое поле рядом со строкой `_seconds.value = i` в `AutoReplyViewModel.kt`.
2.  **Добавьте условие:** Кликните правой кнопкой мыши по красной точке брейкпоинта и в поле **Condition** введите `i == 2`.
3.  **Перезапустите отладку:** Запустите тест в режиме отладки еще раз.

Теперь отладчик остановит выполнение **только тогда**, когда `i` станет равно `2`. Это избавляет от необходимости вручную проходить через итерации `5`, `4` и `3`, экономя время.

#### Шаг 4: Анализ состояния с помощью Evaluate Expression

Когда отладчик остановился на условном брейкпоинте, мы можем изучить текущее состояние программы.

1.  На панели отладки видна переменная `i` со значением `2`.
2.  Допустим, мы хотим проверить что-то более сложное. Нажмите **Alt+F8** (или иконку калькулятора на панели отладки), чтобы открыть окно **Evaluate Expression**.
3.  В этом окне можно выполнять код в текущем контексте. Например, можно ввести:
    -   `_seconds.value` — чтобы увидеть текущее значение `StateFlow`.
    -   `job?.isActive` — чтобы проверить, активна ли еще корутина.
    -   `this` — чтобы изучить все поля `AutoReplyViewModel`.

Используя **Evaluate Expression**, мы можем проверить гипотезы, не перезапуская отладку и не добавляя временные `log`-и в код.

**Вывод:**
-   **Чтение стека** помогло нам быстро понять, *где* искать проблему (внутри `startTimer`).
-   **Условный брейкпоинт** позволил нам пропустить нерелевантные итерации цикла и остановиться точно на моменте перед сбоем.
-   **Evaluate Expression** дало возможность интерактивно исследовать состояние программы и подтвердить наши догадки.

Комбинация этих инструментов позволяет локализовать и анализировать даже сложные баги быстро и эффективно.
